name: 'Accuknox Semgrep Scan'
description: 'Perform Semgrep scan on your repository and upload the results to Accuknox'

inputs:
  token:
    description: 'The token for authenticating with the CSPM panel.'
    required: true
  tenant_id:
    description: 'The ID of the tenant associated with the CSPM panel.'
    required: true
  label:
    description: 'The label created in AccuKnox SaaS for associating scan results.'
    required: true
  endpoint:
    description: 'The URL of the CSPM panel to push the scan results to.'
    required: true
    default: 'cspm.demo.accuknox.com'
  subcommand:
    description: 'Semgrep subcommand to run (e.g. ci, scan)'
    required: true
    default: 'scan'
  config:
    description: 'Semgrep ruleset or config file'
    required: false
  extra_args:
    description: 'Additional arguments to pass to semgrep'
    required: false
    default: ''
  paths:
    description: 'Paths to scan'
    required: false
    default: '.'

runs:
  using: 'composite'
  steps:
    - name: Run Semgrep
      uses: docker://semgrep/semgrep:latest
      with:
        args: >-
          bash -c "
          semgrep ${{ inputs.subcommand }} \
            --json \
            --output semgrep-results.json \
            ${{ inputs.config != '' && format('--config {0}', inputs.config) || '' }} \
            ${{ inputs.extra_args }} \
            ${{ inputs.paths }}"

    - name: Process Results
      shell: bash
      run: |
        jq -c . semgrep-results.json | \
        jq --arg repo "${{ github.repository }}" \
          --arg sha "${{ github.sha }}" \
          --arg ref "${{ github.ref }}" \
          --arg run_id "${{ github.run_id }}" \
          --arg run_number "${{ github.run_number }}" \
          --arg repo_url "${{ github.server_url }}/${{ github.repository }}" \
          --arg repo_run_url "${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}" \
          '. + {
            repo: $repo,
            sha: $sha,
            ref: $ref,
            run_id: $run_id,
            run_number: $run_number,
            repo_url: $repo_url,
            repo_run_url: $repo_run_url,
          }' > results.json

    - name: Extract Code Snippets
      shell: bash
      run: |
        JSON_FILE="results.json"
        
        # Create a jq filter that will process all results at once
        jq -r '.results | to_entries[] | "\(.key) \(.value.path) \(.value.start.line) \(.value.end.line)"' "$JSON_FILE" | \
        while IFS=' ' read -r index path start_line end_line; do
          if [ -f "$path" ]; then
            # Extract the snippet and escape it for jq
            snippet=$(sed -n "${start_line},${end_line}p" "$path" | jq -R -s .)
            # Store in associative array using a delimiter unlikely to appear in code
            echo "$index"$'\x1e'"$snippet"
          fi
        done | \
        # Combine all updates into a single jq program
        jq -R -s '
          split("\n") | 
          map(select(length > 0) | split("\u001e")) | 
          reduce .[] as [$idx, $code] (
            (input | fromjson); 
            setpath(["results", ($idx | tonumber), "extra", "lines"]; $code)
          )
        ' "$JSON_FILE" > updated.json && mv updated.json "$JSON_FILE"

outputs:
  results-file:
    description: 'Path to the JSON results file'
    value: results.json